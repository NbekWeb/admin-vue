{"ast":null,"code":"import { createWebHistory, createRouter } from \"vue-router\";\n// import axios from 'axios';\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\n// import store from '@/state/store';\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n  }\n});\nrouter.beforeEach(async (to, from, next) => {\n  const authRequired = to.matched.some(r => r.meta.authRequired);\n  const publicPages = ['/login', '/register', '/forgot-password'];\n  const isPublicPage = publicPages.includes(to.path);\n  const loggedIn = localStorage.getItem('token');\n  if (!authRequired || isPublicPage) return next();\n  if (!loggedIn) {\n    return next({\n      name: 'login',\n      query: {\n        redirectFrom: to.fullPath\n      }\n    });\n  }\n  next();\n});\n\n// API based Authentication\n// Before each route evaluates...\n// router.beforeEach(async (routeTo, routeFrom, next) => {\n\n//   const authRequired = routeTo.matched.some((route) => route.meta.authRequired);\n\n//   if (!authRequired) return next();\n\n// //   axios.defaults.headers.common['authorization'] = 'Bearer ' + localStorage.getItem('jwt'); // for all requests\n// //   await axios.get('https://api-node.themesbrand.website/profile').then((data) => {\n// //     localStorage.setItem('userdata', JSON.stringify(data.data.user));\n// //     localStorage.setItem('userid', data.data.user._id);\n// //     localStorage.setItem('user', JSON.stringify(data.data.user));\n// //     next();\n// //   }).catch(() => {\n// //     next({ name: 'login', query: { redirectFrom: routeTo.fullPath } });\n// //   });\n// });\n\n// router.beforeEach((routeTo, routeFrom, next) => {\n//   if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n\n//     // Check if auth is required on this route\n//     // (including nested routes).\n//     const authRequired = routeTo.matched.some((route) => route.meta.authRequired);\n\n//     // If auth isn't required for the route, just continue.\n//     if (!authRequired) return next();\n\n//     // If auth is required and the user is logged in...\n//     if (store.getters['auth/loggedIn']) {\n//       // Validate the local user token...\n//       return store.dispatch('auth/validate').then((validUser) => {\n//         // Then continue if the token still represents a valid user,\n//         // otherwise redirect to login.\n//         validUser ? next() : redirectToLogin();\n//       });\n//     }\n\n//     // If auth is required and the user is NOT currently logged in,\n//     // redirect to login.\n//     redirectToLogin();\n\n//     // eslint-disable-next-line no-unused-vars\n//     // eslint-disable-next-line no-inner-declarations\n//     function redirectToLogin() {\n//       // Pass the original route to the login component\n//       next({ name: 'login', query: { redirectFrom: routeTo.fullPath } });\n//     }\n//   } else {\n//     const publicPages = ['/login', '/register', '/forgot-password'];\n//     const authpage = !publicPages.includes(routeTo.path);\n//     const loggeduser = localStorage.getItem('user');\n\n//     if (authpage && !loggeduser) {\n//       return next('/login');\n//     }\n\n//     next();\n//   }\n// });\n\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return;\n  }\n  document.title = routeTo.meta.title + ' | ' + appConfig.title;\n  // If we reach this point, continue resolving the route.\n  next();\n});\nexport default router;","map":{"version":3,"names":["createWebHistory","createRouter","routes","appConfig","router","history","mode","scrollBehavior","to","from","savedPosition","top","left","beforeEach","next","authRequired","matched","some","r","meta","publicPages","isPublicPage","includes","path","loggedIn","localStorage","getItem","name","query","redirectFrom","fullPath","beforeResolve","routeTo","routeFrom","route","Promise","resolve","reject","args","length","Error","error","document","title"],"sources":["C:/Users/UMIDJON/Desktop/default2/src/router/index.js"],"sourcesContent":["import { createWebHistory, createRouter } from \"vue-router\";\n// import axios from 'axios';\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\n// import store from '@/state/store';\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return { top: 0, left: 0 };\n    }\n  },\n});\nrouter.beforeEach(async (to, from, next) => {\n  const authRequired = to.matched.some(r => r.meta.authRequired);\n  const publicPages = ['/login', '/register', '/forgot-password'];\n  const isPublicPage = publicPages.includes(to.path);\n  const loggedIn = localStorage.getItem('token');\n\n  if (!authRequired || isPublicPage) return next();\n\n  if (!loggedIn) {\n    return next({ name: 'login', query: { redirectFrom: to.fullPath } });\n  }\n\n  next();\n});\n\n\n// API based Authentication\n// Before each route evaluates...\n// router.beforeEach(async (routeTo, routeFrom, next) => {\n\n//   const authRequired = routeTo.matched.some((route) => route.meta.authRequired);\n\n//   if (!authRequired) return next();\n\n// //   axios.defaults.headers.common['authorization'] = 'Bearer ' + localStorage.getItem('jwt'); // for all requests\n// //   await axios.get('https://api-node.themesbrand.website/profile').then((data) => {\n// //     localStorage.setItem('userdata', JSON.stringify(data.data.user));\n// //     localStorage.setItem('userid', data.data.user._id);\n// //     localStorage.setItem('user', JSON.stringify(data.data.user));\n// //     next();\n// //   }).catch(() => {\n// //     next({ name: 'login', query: { redirectFrom: routeTo.fullPath } });\n// //   });\n// });\n\n// router.beforeEach((routeTo, routeFrom, next) => {\n//   if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n\n//     // Check if auth is required on this route\n//     // (including nested routes).\n//     const authRequired = routeTo.matched.some((route) => route.meta.authRequired);\n\n//     // If auth isn't required for the route, just continue.\n//     if (!authRequired) return next();\n\n//     // If auth is required and the user is logged in...\n//     if (store.getters['auth/loggedIn']) {\n//       // Validate the local user token...\n//       return store.dispatch('auth/validate').then((validUser) => {\n//         // Then continue if the token still represents a valid user,\n//         // otherwise redirect to login.\n//         validUser ? next() : redirectToLogin();\n//       });\n//     }\n\n//     // If auth is required and the user is NOT currently logged in,\n//     // redirect to login.\n//     redirectToLogin();\n\n//     // eslint-disable-next-line no-unused-vars\n//     // eslint-disable-next-line no-inner-declarations\n//     function redirectToLogin() {\n//       // Pass the original route to the login component\n//       next({ name: 'login', query: { redirectFrom: routeTo.fullPath } });\n//     }\n//   } else {\n//     const publicPages = ['/login', '/register', '/forgot-password'];\n//     const authpage = !publicPages.includes(routeTo.path);\n//     const loggeduser = localStorage.getItem('user');\n\n//     if (authpage && !loggeduser) {\n//       return next('/login');\n//     }\n\n//     next();\n//   }\n// });\n\n\n\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return;\n  }\n  document.title = routeTo.meta.title + ' | ' + appConfig.title;\n  // If we reach this point, continue resolving the route.\n  next();\n});\n\nexport default router;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}